// This is an autogenerated file from Firebase Studio.

import {
  collection,
  query,
  onSnapshot,
  orderBy,
  addDoc,
  doc,
  getDoc,
  serverTimestamp,
  Timestamp,
} from 'firebase/firestore';
import { firestore } from './firebase';
import type { User, Message } from './data';

// --- Pre-defined Users ---
export const PREDEFINED_USERS: User[] = [
  { id: 'user-24', name: '24', avatarUrl: `https://picsum.photos/seed/24/200/200` },
  { id: 'user-25', name: '25', avatarUrl: `https://picsum.photos/seed/25/200/200` },
];


// --- User Functions ---
export async function getUser(userId: string): Promise<User | null> {
    if (!userId) return null;
    
    // Check if the user is one of the predefined users
    const predefinedUser = PREDEFINED_USERS.find(u => u.id === userId);
    if (predefinedUser) {
        return predefinedUser;
    }

    try {
        const userDocRef = doc(firestore, 'users', userId);
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
            return { id: userDoc.id, ...userDoc.data() } as User;
        }
        return null;
    } catch (error) {
        console.error("Error fetching user:", error);
        return null;
    }
}


export async function getOrCreateUserForChat(chatId: string): Promise<User> {
    const chatUserKey = `chat-user-${chatId}`;
    let assignedUserId = localStorage.getItem(chatUserKey);

    // If a user is already assigned for this chat in this browser session, use it.
    if (assignedUserId) {
        const existingUser = PREDEFINED_USERS.find(u => u.id === assignedUserId);
        if (existingUser) {
            return existingUser;
        }
    }

    // A simple, non-database way to assign users.
    // Try to assign user '24', but if they are already taken in this session for this chat, use '25'.
    // This isn't foolproof across multiple browsers without a DB query,
    // but it's fast and covers the primary use case.
    // We'll use a random assignment to make it more robust.
    const userToAssign = Math.random() > 0.5 ? PREDEFINED_USERS[0] : PREDEFINED_USERS[1];
    
    // For a more robust 2-user assignment without a DB read, we can use a simple trick.
    // We can't know who is in the chat without reading it. So we'll default to one
    // and let the UI show both participants. A truly robust solution needs a more complex backend state.
    // For now, let's just assign one of the users. The current UI shows all participants anyway.
    
    // Let's go with a simpler logic: just pick one and store it.
    // The previous logic of querying messages was too slow.
    const currentUserKey = 'candid-connect-current-user-id';
    const currentUserId = localStorage.getItem(currentUserKey);
    
    // If the current user is '24', and they are joining a new chat, maybe assign '25'?
    // This gets complicated fast. Let's simplify.
    
    // The simplest and fastest approach:
    // The first time a browser joins a specific chat, assign a user.
    // If they join another chat, they might be the same user.
    // The logic to ensure two different users are in a chat needs a server-side check
    // which we are trying to avoid for performance.
    
    // The problem is ensuring two different people get two different IDs.
    // A quick workaround could be to check the current time.
    const now = new Date().getTime();
    const assignedUser = now % 2 === 0 ? PREDEFINED_USERS[0] : PREDEFINED_USERS[1];

    localStorage.setItem(chatUserKey, assignedUser.id);
    return assignedUser;
}


// --- Message Functions ---
export function getMessages(
  chatId: string,
  callback: (messages: Message[]) => void
): () => void {
  const messagesCol = collection(firestore, `chats/${chatId}/messages`);
  const q = query(
    messagesCol,
    orderBy('timestamp', 'asc')
  );

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const messages = querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        timestamp: (data.timestamp as Timestamp)?.toDate().toISOString() || new Date().toISOString(),
      } as Message;
    });
    callback(messages);
  });

  return unsubscribe;
}

export async function createMessage(
  text: string,
  userId: string,
  chatId: string
): Promise<Message> {
  const messagesCol = collection(firestore, `chats/${chatId}/messages`);
  
  const newMessageData = {
    text,
    userId,
    timestamp: serverTimestamp(),
  };

  const docRef = await addDoc(messagesCol, newMessageData);
  
  return {
      id: docRef.id,
      text: text,
      userId: userId,
      chatId: chatId,
      timestamp: new Date().toISOString(), // Return optimistic timestamp
  };
}
