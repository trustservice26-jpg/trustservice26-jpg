// This is an autogenerated file from Firebase Studio.

import {
  collection,
  query,
  onSnapshot,
  orderBy,
  addDoc,
  doc,
  getDoc,
  serverTimestamp,
  Timestamp,
  getDocs,
  limit,
} from 'firebase/firestore';
import { firestore } from './firebase';
import type { User, Message } from './data';

// --- Pre-defined Users ---
export const PREDEFINED_USERS: User[] = [
  { id: 'user-24', name: '24', avatarUrl: `https://picsum.photos/seed/24/200/200` },
  { id: 'user-25', name: '25', avatarUrl: `https://picsum.photos/seed/25/200/200` },
];


// --- User Functions ---
export async function getUser(userId: string): Promise<User | null> {
    if (!userId) return null;
    
    // Check if the user is one of the predefined users
    const predefinedUser = PREDEFINED_USERS.find(u => u.id === userId);
    if (predefinedUser) {
        return predefinedUser;
    }

    try {
        const userDocRef = doc(firestore, 'users', userId);
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
            return { id: userDoc.id, ...userDoc.data() } as User;
        }
        return null;
    } catch (error) {
        console.error("Error fetching user:", error);
        return null;
    }
}


export async function getOrCreateUserForChat(chatId: string): Promise<User> {
    const messagesCol = collection(firestore, `chats/${chatId}/messages`);
    const q = query(messagesCol, orderBy('timestamp', 'desc'), limit(50));
    const querySnapshot = await getDocs(q);
    const userIdsInChat = new Set(querySnapshot.docs.map(d => d.data().userId as string));

    // If user '24' is not in the chat, assign this user.
    if (!userIdsInChat.has(PREDEFINED_USERS[0].id)) {
        return PREDEFINED_USERS[0];
    }
    
    // If user '24' is in the chat, but user '25' is not, assign user '25'.
    if (!userIdsInChat.has(PREDEFINED_USERS[1].id)) {
        return PREDEFINED_USERS[1];
    }

    // Default to user '24' if both are somehow present or if the chat is empty.
    // This could happen if more than two people join, but for a 2-user chat, this logic is sound.
    return PREDEFINED_USERS[0];
}


// --- Message Functions ---
export function getMessages(
  chatId: string,
  callback: (messages: Message[]) => void
): () => void {
  const messagesCol = collection(firestore, `chats/${chatId}/messages`);
  const q = query(
    messagesCol,
    orderBy('timestamp', 'asc')
  );

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const messages = querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        ...data,
        timestamp: (data.timestamp as Timestamp)?.toDate().toISOString() || new Date().toISOString(),
      } as Message;
    });
    callback(messages);
  });

  return unsubscribe;
}

export async function createMessage(
  text: string,
  userId: string,
  chatId: string
): Promise<Message> {
  const messagesCol = collection(firestore, `chats/${chatId}/messages`);
  
  const newMessageData = {
    text,
    userId,
    timestamp: serverTimestamp(),
  };

  const docRef = await addDoc(messagesCol, newMessageData);
  
  return {
      id: docRef.id,
      text: text,
      userId: userId,
      chatId: chatId,
      timestamp: new Date().toISOString(), // Return optimistic timestamp
  };
}
