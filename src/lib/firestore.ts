// This is an autogenerated file from Firebase Studio.

import {
  collection,
  query,
  where,
  getDocs,
  addDoc,
  onSnapshot,
  orderBy,
  limit,
  doc,
  getDoc,
  setDoc,
} from 'firebase/firestore';
import { firestore } from './firebase';
import type { User, Message, Room } from './data';
import { v4 as uuidv4 } from 'uuid';

// --- User Functions ---

// One-time fetch
export async function getUsers(): Promise<User[]> {
  const usersCol = collection(firestore, 'users');
  const userSnapshot = await getDocs(usersCol);
  const userList = userSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as User));
  return userList;
}

// Real-time listener
export function getUsersRealtime(callback: (users: User[]) => void): () => void {
  const usersCol = collection(firestore, 'users');
  const q = query(usersCol);
  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const userList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as User));
    callback(userList);
  });
  return unsubscribe;
}

export async function getUser(userId: string): Promise<User | null> {
    if (!userId) return null;
    const userDocRef = doc(firestore, 'users', userId);
    const userDoc = await getDoc(userDocRef);
    if (userDoc.exists()) {
        return { id: userDoc.id, ...userDoc.data() } as User;
    }
    return null;
}


export async function addUser(name: string): Promise<User> {
  const newUser: Omit<User, 'id'> = {
    name,
    avatarUrl: `https://picsum.photos/seed/${Date.now()}/200/200`,
    isOnline: true,
  };
  const docRef = await addDoc(collection(firestore, 'users'), newUser);
  return { id: docRef.id, ...newUser };
}

// --- Room Functions ---
// One-time fetch
export async function getRooms(): Promise<Room[]> {
    const roomsCol = collection(firestore, 'rooms');
    const roomSnapshot = await getDocs(roomsCol);
    const roomList = roomSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Room));
    return roomList;
}

// Real-time listener
export function getRoomsRealtime(callback: (rooms: Room[]) => void): () => void {
  const roomsCol = collection(firestore, 'rooms');
  const q = query(roomsCol);
  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const roomList = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as Room));
    callback(roomList);
  });
  return unsubscribe;
}

// --- Message Functions ---

export function getMessages(
  chatId: string,
  chatType: 'room' | 'dm',
  callback: (messages: Message[]) => void
): () => void {
  const messagesCol = collection(firestore, 'messages');
  let q;

  if (chatType === 'room') {
    q = query(
      messagesCol,
      where('roomId', '==', chatId),
      orderBy('timestamp', 'asc')
    );
  } else {
    // For DMs, we need to query for messages between the two users.
    // We'll create a compound ID for the DM chat to query against.
    const currentUser = 'user-1'; // Assuming a static current user for now
    const dmId = [currentUser, chatId].sort().join('-');
    q = query(
      messagesCol,
      where('dmId', '==', dmId),
      orderBy('timestamp', 'asc')
    );
  }

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    const messages = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      timestamp: doc.data().timestamp.toDate().toISOString(),
    } as Message));
    callback(messages);
  });

  return unsubscribe;
}

export async function createMessage(
  text: string,
  chatId: string,
  chatType: 'room' | 'dm',
  userId: string
): Promise<Message> {
  const newMessage: Omit<Message, 'id' | 'timestamp'> & { timestamp: Date } = {
    text,
    userId,
    timestamp: new Date(),
  };

  if (chatType === 'room') {
    newMessage.roomId = chatId;
  } else {
    const dmId = [userId, chatId].sort().join('-');
    newMessage.dmId = dmId;
  }

  const docRef = await addDoc(collection(firestore, 'messages'), newMessage);
  
  return {
      id: docRef.id,
      text: newMessage.text,
      userId: newMessage.userId,
      timestamp: newMessage.timestamp.toISOString(),
      ...(newMessage.roomId && { roomId: newMessage.roomId }),
      ...(newMessage.dmId && { dmId: newMessage.dmId }),
  };
}

// Helper to create initial data if collections are empty
export async function seedInitialData() {
    const usersSnap = await getDocs(query(collection(firestore, 'users'), limit(1)));
    if (usersSnap.empty) {
        const defaultUsers = [
            { id: 'user-1', name: 'You', avatarUrl: 'https://picsum.photos/seed/1/200/200', isOnline: true },
            { id: 'user-2', name: 'Ben', avatarUrl: 'https://picsum.photos/seed/2/200/200', isOnline: true },
        ];
        for (const user of defaultUsers) {
            await setDoc(doc(firestore, 'users', user.id), {name: user.name, avatarUrl: user.avatarUrl, isOnline: user.isOnline });
        }
    }

    const roomsSnap = await getDocs(query(collection(firestore, 'rooms'), limit(1)));
    if (roomsSnap.empty) {
        const generalRoomRef = doc(firestore, 'rooms', 'general');
        await setDoc(generalRoomRef, { name: 'general' });
    }
}
